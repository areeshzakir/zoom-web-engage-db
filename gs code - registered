//=====================================================================//
// WebEngage: "Webinar Registered" (same logic as Attended, final)
// - Reads from "reg_web" tab
// - Works with form submit (e provided) OR manual Run (processes last row)
// - Unique globals (REG_*), unique helpers (reg*)
// - Uniform variables: user_id, email, name, mobile
// - eventTime strictly from Webinar Date (parity with Attended)
//=====================================================================//

// ====== EDIT THESE CONSTANTS ====== //
const REG_SHEET_ID               = '1Hqg2dtoOEgXnGGC6LmtF_FiM3CiQIWomXBW9VvcuqCQ';
const REG_FORM_SHEET_NAME        = 'reg_web';              // <-- your source tab
const REG_RESULTS_SHEET_NAME     = 'weWebinarRegResults';  // output sheet name

const REG_WEBENGAGE_LICENSE_CODE = '~2024b5d8';  // e.g. "~2024b5d8"
const REG_WEBENGAGE_API_KEY      = '78ac5485-3067-4403-bb13-b367becdea16';

// Toggle: also create/update user in WebEngage before firing event?
const REG_CREATE_USERS           = true;

// Brandable event name (shows as a separate event in WebEngage)
const REG_EVENT_NAME             = 'Plutus Webinar Registered';    // e.g. 'Plutus webinar registered'

// ====== HEADERS (must match your sheet) ====== //
const REG_HDR_USER_NAME_ORIG     = 'User Name (Original Name)';
const REG_HDR_FIRST_NAME         = 'First Name';
const REG_HDR_LAST_NAME          = 'Last Name';                 // not sent (kept minimal)
const REG_HDR_EMAIL              = 'Email';
const REG_HDR_PHONE              = 'Phone';

const REG_HDR_REG_TIME           = 'Registration Time';
const REG_HDR_APPROVAL_STATUS    = 'Approval Status';
const REG_HDR_REG_SOURCE         = 'Registration Source';
const REG_HDR_ATTENDANCE_TYPE    = 'Attendance Type';
const REG_HDR_WEBINAR_NAME       = 'Webinar name';
const REG_HDR_WEBINAR_DATE       = 'Webinar Date';

//=====================================================================//
// Helpers (prefixed with reg*)
//=====================================================================//
function regFormatToRFC3339(date) {
  return Utilities.formatDate(date, 'Asia/Kolkata', "yyyy-MM-dd'T'HH:mm:ssZ");
}
function regNowIST() {
  return Utilities.formatDate(new Date(), 'Asia/Kolkata', 'yyyy-MM-dd HH:mm:ss');
}
function regGetByHeader(responses, headers, headerName) {
  const idx = headers.indexOf(headerName);
  return idx !== -1 ? responses[idx] : '';
}
function regNormalize91(raw) {
  if (!raw) return '';
  const digits = String(raw).replace(/\D+/g, '');
  if (!digits) return '';
  return digits.startsWith('91') ? digits : `91${digits}`;
}
function regParseDateLoose(v) {
  if (!v) return null;
  try {
    if (Object.prototype.toString.call(v) === '[object Date]' && !isNaN(v)) return v;
    const d = new Date(v);
    return isNaN(d.getTime()) ? null : d;
  } catch (_) { return null; }
}
function regSafeParse(t) { try { return JSON.parse(t || '{}'); } catch (_) { return {}; } }

function regEnsureResultSheet(ss) {
  let out = ss.getSheetByName(REG_RESULTS_SHEET_NAME);
  if (!out) {
    out = ss.insertSheet(REG_RESULTS_SHEET_NAME);
    out.appendRow([
      'When(IST)', 'user_id', 'mobile', 'email',
      'Webinar Name', 'Webinar Date', 'Registration Time',
      'Registration Source', 'Attendance Type', 'Approval Status',
      'User Status', 'Event Status', 'Note'
    ]);
  }
  return out;
}
function regAppendAudit(out, row) { out.appendRow(row); }

//=====================================================================//
// Entry point (safe): add Installable Trigger to this on form submit.
// If run manually (no e), it processes the last row gracefully.
//=====================================================================//
function onWebinarRegistrationSubmit(e) {
  try {
    const ss  = SpreadsheetApp.openById(REG_SHEET_ID);
    const src = ss.getSheetByName(REG_FORM_SHEET_NAME);
    const out = regEnsureResultSheet(ss);

    if (!src) {
      Logger.log('Source sheet not found: ' + REG_FORM_SHEET_NAME);
      regAppendAudit(out, [regNowIST(), '', '', '', '', '', '', '', '', '', 'SKIPPED', 'SKIPPED', 'Missing source sheet']);
      return;
    }

    const lastCol = src.getLastColumn();
    if (lastCol < 1) {
      regAppendAudit(out, [regNowIST(), '', '', '', '', '', '', '', '', '', 'SKIPPED', 'SKIPPED', 'No columns in source']);
      return;
    }
    const headers = src.getRange(1, 1, 1, lastCol).getValues()[0];

    // responses from trigger OR last row when run manually
    let responses;
    if (e && e.values && Array.isArray(e.values)) {
      responses = e.values;
    } else {
      const lastRow = src.getLastRow();
      if (lastRow < 2) {
        regAppendAudit(out, [regNowIST(), '', '', '', '', '', '', '', '', '', 'SKIPPED', 'SKIPPED', 'No data rows to process']);
        return;
      }
      responses = src.getRange(lastRow, 1, 1, lastCol).getValues()[0];
    }

    // ---------- Uniform variables ----------
    const mobile       = regNormalize91(regGetByHeader(responses, headers, REG_HDR_PHONE));
    const email        = regGetByHeader(responses, headers, REG_HDR_EMAIL);
    const user_id      = (mobile && mobile.trim()) || (email && email.trim()) || '';  // Phone -> Email (no UserID column here)

    const firstName    = (regGetByHeader(responses, headers, REG_HDR_FIRST_NAME) || '').toString().trim();
    const originalName = (regGetByHeader(responses, headers, REG_HDR_USER_NAME_ORIG) || '').toString().trim();
    const name         = firstName || originalName || '';

    // Event fields
    const webinarName  = regGetByHeader(responses, headers, REG_HDR_WEBINAR_NAME);
    const webinarDateV = regGetByHeader(responses, headers, REG_HDR_WEBINAR_DATE);
    const regTimeV     = regGetByHeader(responses, headers, REG_HDR_REG_TIME);
    const regSource    = regGetByHeader(responses, headers, REG_HDR_REG_SOURCE);
    const attendanceTy = regGetByHeader(responses, headers, REG_HDR_ATTENDANCE_TYPE);
    const approval     = regGetByHeader(responses, headers, REG_HDR_APPROVAL_STATUS);

    if (!user_id) {
      Logger.log('Missing user_id (Phone/Email). Skipping.');
      regAppendAudit(out, [
        regNowIST(), '', mobile, email,
        webinarName, webinarDateV, regTimeV,
        regSource, attendanceTy, approval,
        'FAILED: Missing user_id', 'SKIPPED', 'Guard: no identifier'
      ]);
      return;
    }

    // === Parity with Attended: eventTime strictly from Webinar Date ===
    const when = regParseDateLoose(webinarDateV) || new Date();
    const eventTimeRFC3339 = regFormatToRFC3339(when);

    // 1) (Optional) Create/Update user
    let userStatus = 'SKIPPED';
    if (REG_CREATE_USERS) {
      userStatus = regUpsertUser(user_id, name, email, mobile, originalName);
    }

    // 2) Fire "Webinar Registered" event
    const eventStatus = regFireRegistrationEvent(user_id, eventTimeRFC3339, {
      WebinarName: webinarName || '',
      WebinarDate: webinarDateV || '',
      RegistrationTime: regTimeV || '',
      RegistrationSource: regSource || '',
      AttendanceType: attendanceTy || '',
      ApprovalStatus: approval || '',
      UserNameOriginal: originalName || '',
      UserEmail: email || ''
    });

    // 3) Audit row
    regAppendAudit(out, [
      regNowIST(), user_id, mobile, email,
      webinarName, webinarDateV, regTimeV,
      regSource, attendanceTy, approval,
      userStatus, eventStatus, ''
    ]);

    Logger.log('Processed registration for user_id=' + user_id);

  } catch (err) {
    // Final guard: never throw; log and record
    try {
      const ss  = SpreadsheetApp.openById(REG_SHEET_ID);
      const out = regEnsureResultSheet(ss);
      regAppendAudit(out, [regNowIST(), '', '', '', '', '', '', '', '', '', 'FAILED', 'FAILED', 'Exception: ' + err.message]);
    } catch (inner) {
      Logger.log('Unhandled error: ' + err.message);
    }
  }
}

//=====================================================================//
// WebEngage calls (unique names)
//=====================================================================//
function regUpsertUser(user_id, name, email, mobile, originalName) {
  const payload = {
    userId: user_id,
    email: email || undefined,
    firstName: (name && String(name).trim()) || undefined,
    phone: mobile || undefined,
    whatsappOptIn: true,
    emailOptIn: true,
    attributes: {
      whatsappOptIn: true,
      emailOptIn: true,
      originalName: (originalName && String(originalName).trim()) || undefined
    }
  };

  Logger.log('User Payload: ' + JSON.stringify(payload));

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { Authorization: `Bearer ${REG_WEBENGAGE_API_KEY}` },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const resp = UrlFetchApp.fetch(
      `https://api.webengage.com/v1/accounts/${REG_WEBENGAGE_LICENSE_CODE}/users`,
      options
    );
    const code = resp.getResponseCode();
    const body = regSafeParse(resp.getContentText());
    Logger.log(`User API Code: ${code}`);
    Logger.log(`User API Body: ${JSON.stringify(body)}`);

    if (code === 200 || code === 201) {
      const status = body.response && body.response.status;
      return status === 'queued' ? 'User created/updated' : (status || 'OK');
    }
    return (body.response && (body.response.status || body.response.message)) || (body.message || 'Error');
  } catch (err) {
    Logger.log('User API error: ' + err.message);
    return 'Error: ' + err.message;
  }
}

function regFireRegistrationEvent(user_id, eventTimeRFC3339, eventData) {
  const payload = {
    userId: user_id,
    eventName: REG_EVENT_NAME,
    eventTime: eventTimeRFC3339,
    eventData: eventData
  };

  Logger.log('Event Payload: ' + JSON.stringify(payload));

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { Authorization: `Bearer ${REG_WEBENGAGE_API_KEY}` },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const resp = UrlFetchApp.fetch(
      `https://api.webengage.com/v1/accounts/${REG_WEBENGAGE_LICENSE_CODE}/events`,
      options
    );
    const code = resp.getResponseCode();
    const body = regSafeParse(resp.getContentText());
    Logger.log(`Event API Code: ${code}`);
    Logger.log(`Event API Body: ${JSON.stringify(body)}`);

    return (code >= 200 && code < 300)
      ? 'Event Triggered Successfully'
      : (body.response && (body.response.message || body.response.status)) || (body.message || 'Error');
  } catch (err) {
    Logger.log('Event API error: ' + err.message);
    return 'Error: ' + err.message;
  }
}
//=====================================================================//
// END
//=====================================================================//